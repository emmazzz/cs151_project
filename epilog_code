
/*
================================================================================
  utilities
================================================================================
*/

/*
  split_string_into_words: only works for lower case letters and numbers though...
  split_string_into_words(+String, -WordList)
*/
split_string_into_words(S, Res) :-
    evaluate(readstringall(S),X) & list_stringify(X, Res)
list_stringify([],[])
list_stringify(cons(X, L), cons(S, SL)) :-
    list_stringify(L, SL) &
    evaluate(stringify(X),S)

/*
  drop_last_elem_from_list(+InputList, -ResultList)
*/
drop_last_elem_from_list([X], [])
drop_last_elem_from_list(cons(X, L), cons(X, RL)) :-
   drop_last_elem_from_list(L, RL)

/*
  has_suffix(+Input, +Suffix)
*/
has_suffix(Input, Suffix) :-
  evaluate(stringappend(".*",Suffix),Pattern) &
  evaluate(matches(Input, Pattern), [A]) &
  same(A, Input)
/*
  has_prefix(+Input, +Prefix)
*/
has_prefix(Input, Prefix) :-
  evaluate(stringappend(Prefix, ".*"),Pattern) &
  evaluate(matches(Input, Pattern), [A]) &
  same(A, Input)


/*
================================================================================
  query.pl functions
================================================================================
*/

/*
  find_all_movies_by_type(+Role, +ProvidedInfo, -Movies, +Database)
*/
find_all_movies_by_type(NewRole, ProvidedInfo, Movies, Database) :-
	same(NewRole,stardirector) & find_all_movies_by_person(AttrList, Movies, Database)

find_all_movies_by_type(NewRole, ProvidedInfo, Movies, Database) :-
	same(NewRole,star) &
	find_all_movies_by_star(ProvidedInfo, Movies, Database)

find_all_movies_by_type(NewRole, ProvidedInfo, Movies, Database) :-
	same(NewRole,director) &
	find_all_movies_by_director(ProvidedInfo, Movies, Database)

/*
  find_all_movies_by_person(+Person, -Movies, +Database)
*/
find_all_movies_by_person(Person, Movies, Database) :-
  find_all_movies_by_star(Person, StarredMovies, Database) &
  find_all_movies_by_director(Person, DirectedMovies, Database) &
  evaluate(append(StarredMovies, DirectedMovies), Movies)

/*
  find_all_movies_by_star(+Star, -Movies, +Database)
*/
find_all_movies_by_star(Star, Movies, Database) :-
  evaluate(setofall(Movie,find_one_movie_by_star(Star, Movie, Database)), Movies)
find_one_movie_by_star(Star, Movie, Database) :-
  member(star(Movie, Stars, _), Database) &
  member(Star, Stars)

/*
  find_all_movies_by_director(+Director, -Movies, +Database)
*/
find_all_movies_by_director(Director, Movies, Database) :-
  evaluate(setofall(Movie,find_one_movie_by_director(Director, Movie, Database)), Movies)
find_one_movie_by_director(Director, Movie, Database) :-
  member(star(Movie, _, Director), Database)


/*
================================================================================
  token.pl functions
================================================================================
*/

/*
  exists_in_database_left(+WordList, -Result, +Database, -RelevantData, -ValidRole, -ProvidedInfo)
  check if a suffix of WordList exists in the database and extract information from it.
  for example, if ["James","Cameron"] exists in the database as a director, then
  calling exists_in_database_left on ["some", "other", "strings", "James","Cameron"]
  will retrieve ["James","Cameron"].
*/
exists_in_database_left(WordList, WordList, Database,RelevantData, stardirector,ProvidedInfo) :-
  exists_in_database(WordList, Database,RelevantData, stardirector,ProvidedInfo)

exists_in_database_left(cons(_, ShorterWordList), Result, Database,RelevantData, ValidRoles,ProvidedInfo) :-
  exists_in_database_left(ShorterWordList, Result, Database,RelevantData, ValidRoles,ProvidedInfo)

/*
  exists_in_database_right(+WordList, -Result, +Database, -RelevantData, -ValidRole, -ProvidedInfo)
  check if a prefix of WordList exists in the database and extract information from it.
  for example, if ["James","Cameron"] exists in the database as a director, then
  calling exists_in_database_left on ["James","Cameron", "some", "other", "strings"]
  will retrieve ["James","Cameron"].
*/
exists_in_database_right(WordList, WordList, Database,RelevantData, stardirector,ProvidedInfo) :-
  exists_in_database(WordList, Database,RelevantData, stardirector,ProvidedInfo)

exists_in_database_right(WordList, Result, Database,RelevantData, ValidRoles,ProvidedInfo) :-
  drop_last_elem_from_list(WordList, ShorterWordList) &
  exists_in_database_right(ShorterWordList, Result, Database,RelevantData, ValidRoles,ProvidedInfo)

/*
  exists_in_database(+WordList, +Database, -RelevantData, -ValidRole, -ProvidedInfo)
  check if WordList exists in the database and extract information from it.
*/
exists_in_database(WordList, Database,RelevantData, movie,ProvidedInfo) :-
  member(star(WordList, Stars, Director), Database) &
  same(RelevantData, [WordList, Stars, Director]) &
  same(ProvidedInfo, WordList)

exists_in_database(WordList, Database,RelevantData, star,ProvidedInfo) :-
  ~person_both(WordList,Database) &
  member(star(Movie, X, Director), Database) & member(WordList,X) &
  same(RelevantData, [Movie, X, Director]) &
  same(ProvidedInfo, WordList)

exists_in_database(WordList, Database,RelevantData, director,ProvidedInfo) :-
  ~person_both(WordList,Database) &
  member(star(Movie, Stars, WordList), Database) &
  same(RelevantData, [Movie,Stars, WordList]) &
  same(ProvidedInfo, WordList)

exists_in_database(WordList, Database,RelevantData, stardirector,ProvidedInfo) :-
  person_both(WordList,Database) &
  same(ProvidedInfo, WordList)

/*
  person_both(+Person, +Database)
  true if a person serves both as director and star
*/
person_both(Person,Database) :-
  member(star(_,_,Person),Database) &
  member(star(_,S2,_),Database) & member(Person,S2)

/*
  eliminate_double_negation(+InputList, -ResultList)
  remove consecutive negation words from WordList
*/
eliminate_double_negation([],[])
eliminate_double_negation(cons(Word1,cons(Word2, Rest)),Result) :-
  negToken(Word1,_) &
  negToken(Word2,_) &
  eliminate_double_negation(Rest, Result)
eliminate_double_negation(cons(Word,Rest),cons(Word,Result)) :-
  ~negToken(Word,_) &
  eliminate_double_negation(Rest, Result)
eliminate_double_negation(cons(Head,cons(Word,Rest)),cons(Head,cons(Word,Result))) :-
  ~negToken(Word,_) &
  eliminate_double_negation(Rest, Result)

/* lara*/


/* */

matchesOrNotProvided(PAttr,ValidRoles, _, NewRole) :- same(PAttr, ValidRoles) & same(NewRole, PAttr)
matchesOrNotProvided(PAttr,ValidRoles, _, NewRole):- ~same(PAttr, ValidRoles) & ~same(PAttr, notspecified) & same(ValidRoles, stardirector)
  & same(NewRole, PAttr)
matchesOrNotProvided(PAttr,ValidRoles, _, NewRole):- ~same(PAttr, ValidRoles)& same(PAttr, notspecified) & ~same(ValidRoles, stardirector) &
  same(NewRole, ValidRoles)
matchesOrNotProvided(PAttr,ValidRoles,ProvidedInfo, NewRole) :- ~same(PAttr, ValidRoles) & same(PAttr,notspecified) & same(ValidRoles = stardirector) &
 concat_string_list(ProvidedInfo, Strinfo)& same(OutputMessage1,Strinfo) & same(OutputMessage2, " has served as both a star and director. Are you looking for movies with him as (a) star, (b) as a director or (c) all movies he was involved in in any capacity? Enter your preference: ") &
  same(user_input,"my input message") & setRole(user_input,NewRole)


setRole(In,NewRole):- same(In, "a") & same(NewRole, star)
setRole(In,NewRole):- same(In, "b")& same(NewRole, director)
setRole(In,NewRole):- same(In, "c")& same(NewRole, stardirector)
setRole(In,NewRole):- ~same(In, "a") & ~same(In,"b") & ~same(In,"c")& same(NewRole, stardirector) & same(OutputMessage1,"Didn't quite catch that. We're showing you all the results anyway.")


/* Plural movie requested */
attributeFromList(_, Database, QAttr, PAttr, _, Message,Suffix, ValidRoles, ProvidedInfo) :-
  same(QAttr, movie)& same(Suffix, "s") & matchesOrNotProvided(PAttr,ValidRoles, ProvidedInfo, NewRole) &
  same(M, "You might be looking for the movies") & find_all_movies_by_type(NewRole, ProvidedInfo, Movies, Database) &
  concat_string_list_of_lists(Movies,Comb) &
  concat_string_list([M,Comb], Message)

find_query_attributes(WordList, QAttr, PAttr, Suffix) :- pattern1(WordList, QAttr, PAttr, Suffix)
find_query_attributes(WordList, QAttr, PAttr, Suffix) :- pattern2(WordList, QAttr, PAttr, Suffix)
%find_question_attribute(WordList, Attr) :- pattern2(WordList, Attr)
find_query_attributes(WordList, QAttr, PAttr, Suffix) :-
  ~pattern1(WordList, QAttr, PAttr, Suffix) &
  ~pattern2(WordList, QAttr, PAttr, Suffix) &
  same(QAttr, "randomInfo") %all else fails choose a random one not provided info

%Give ... attribute; e.g. Give me the movie with Bill Pullman
qWordPat1("give")
qWordPat1("who")
qWordPat1("what")
qWordPat1("show")

% lara
pattern1(WordList, ResultQ,ResultP, Suffix) :- member(QW, WordList) &string_lower(QW,QWL) &
  qWordPat1(QWL) & nth1(QInd, WordList, QW) & member(X, WordList) & token(X, ResultQ, Suffix)&
  nth1(AInd, WordList, X) & evaluate(min(AInd,QInd, QInd)) & ~same(AInd,QInd) & member(Y, WordList)&  token(Y,ResultP,_)& nth1(PInd, WordList, Y) & evaluate(min(PInd,AInd, AInd)) & ~same(PInd,AInd)

pattern1(WordList, ResultQ,ResultP, Suffix) :- member(QW, WordList) &string_lower(QW,QWL) &
  qWordPat1(QWL) & nth1(QInd, WordList, QW) &member(X, WordList) &token(X, ResultQ, Suffix) &
  nth1(AInd, WordList, X) & evaluate(min(QInd,AInd,QInd)) & ~same(QInd,AInd) & ~negPatternHelper(_,WordList,ResultP,_,WordList,AInd)& same(ResultP = notspecified)

pattern2(WordList, ResultQ,ResultP, Suffix) :- member(QW, WordList) &string_lower(QW,QWL)&
  qWordPat1(QWL) &nth1(QInd, WordList, QW)& member(X, WordList) & token(X, ResultQ, Suffix)&
  nth1(AInd, WordList, X) & evaluate(min(QInd,AInd, QInd)) & ~same(QInd,AInd) & member(Y, WordList) &token(Y,ResultP,_) &nth1(PInd, WordList, Y) & evaluate(min(PInd,AInd, PInd)) & ~same(PInd,AInd)
pattern2(WordList, ResultQ,ResultP, Suffix) :- member(QW, WordList) &string_lower(QW,QWL) &
  qWordPat1(QWL)& nth1(QInd, WordList, QW)& member(X, WordList)& token(X, ResultQ, Suffix)&
  nth1(AInd, WordList, X) & evaluate(min(QInd,AInd, QInd)) & ~same(QInd,AInd) & ~negPatternHelper(_,WordList,ResultP,_,WordList,AInd)& same(ResultP, notspecified)

negPatternHelper(Y,WordList,ResultP,PInd,WordList,AInd) :- member(Y, WordList) & token(Y,ResultP,_) & nth1(PInd, WordList, Y) & evaluate(min(PInd,AInd, AInd)) & ~same(PInd,AInd)


token(S, A, Suffix) :- string_lower(S, LowS) & attribute_token(LowS, A, Suffix)
attribute_token(S, star,Suffix) :- string_concat("star", Suffix, S)
attribute_token(S, star,Suffix) :- string_concat("act", Suffix, S)
attribute_token(S, director,Suffix) :- string_concat("direct", Suffix, S)
attribute_token(S, director,_) :- same(S,"by")
attribute_token(S, director,Suffix) :- string_concat("filmmaker", Suffix, S)
attribute_token(S, director,Suffix) :- string_concat("made", Suffix, S)
attribute_token(S, director,Suffix) :- string_concat("mak", Suffix, S) %making, make
attribute_token(S, movie, Suffix) :- string_concat("movie", Suffix, S) %movie, movies
attribute_token(S, movie,Suffix) :-  ~same(S,"filmmaker")& string_concat("film", Suffix, S)
attribute_token(S, movie,Suffix) :- string_concat("flick", Suffix, S)
negToken("not", neg)
negToken("no", neg)
negToken(S, neg) :- string_concat(_,"n't",S)



  /* concat_string_list
  concat_string_list_of_lists 
  string_concat -- builtin
  string_lower
  nth1*/
